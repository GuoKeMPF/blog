---
title: 所有权
order: 10
---


# 所有权

所有权是Rust最独特的特性，它让Rust 无需GC（Garbage Collection）就可以保证内存安全。


## 什么是所有权

所有程序都必须管理它们在运行时使用计算机内存的方式。有些语言具有垃圾收集功能，会在程序运行时定期查找不再使用的内存；在其他语言中，程序员必须显式分配和释放内存。

Rust 使用第三种方法：通过所有权系统和编译器检查的一组规则来管理内存。如果违反任何规则，程序将无法编译。所有权的任何功能都不会减慢程序运行的速度。


:::info{title="堆栈和堆"}
栈Stack和堆Heap

许多编程语言并不要求您经常考虑堆栈和堆。但在像 Rust 这样的系统编程语言中，值是在堆栈上还是在堆上会影响语言的行为方式以及为什么必须做出某些决定。本章稍后将描述与堆栈和堆相关的所有权部分，因此这里是准备中的简要说明。

堆栈和堆都是可供代码在运行时使用的内存部分，但它们的结构方式不同。堆栈按照获取值的顺序存储值，并按照相反的顺序删除值。这称为后进先出。想象一叠盘子：当你添加更多盘子时，你把它们放在一堆盘子的顶部，当你需要一个盘子时，你从上面拿一个。从中间或底部添加或删除板也不起作用！添加数据称为压入堆栈，删除数据称为从堆栈弹出。存储在堆栈上的所有数据都必须具有已知的固定大小。编译时大小未知或大小可能更改的数据必须存储在堆上。

堆的组织性较差：当您将数据放入堆上时，您会请求一定量的空间。内存分配器在堆中找到一个足够大的空位，将其标记为正在使用，并返回一个指针，它是该位置的地址。这个过程称为在堆上分配，有时缩写为分配（将值推入堆栈不被视为分配）。因为指向堆的指针是已知的固定大小，所以您可以将指针存储在堆栈上，但是当您需要实际数据时，必须跟随指针。想象一下坐在一家餐馆里。当您进入时，请说出您的团体人数，然后主人会找到一张适合每个人的空桌子并带您前往那里。如果您的团队中有人迟到，他们可以询问您坐在哪里以便找到您。

压入堆栈比在堆上分配更快，因为分配器永远不需要搜索存储新数据的位置；该位置始终位于堆栈的顶部。相比之下，在堆上分配空间需要更多的工作，因为分配器必须首先找到足够大的空间来容纳数据，然后进行簿记，为下一次分配做准备。

访问堆中的数据比访问堆栈中的数据慢，因为您必须遵循指针才能到达那里。如果现代处理器在内存中的跳跃次数更少，那么它们的速度就会更快。继续类比，考虑餐厅的服务员从许多桌子上点菜。在转到下一张桌子之前先在一张桌子上获得所有订单是最有效的。从 A 表中获取订单，然后从 B 表中获取订单，然后再次从 A 中获取订单，然后再次从 B 中获取订单，这将是一个慢得多的过程。出于同样的原因，如果处理器处理靠近其他数据（因为它在堆栈上）而不是较远的数据（因为它可以在堆上）的数据，那么它可以更好地完成工作。

当您的代码调用函数时，传递给函数的值（可能包括指向堆上数据的指针）和函数的局部变量被推送到堆栈上。当函数结束时，这些值将从堆栈中弹出。

跟踪代码的哪些部分正在使用堆上的哪些数据、最大限度地减少堆上的重复数据量以及清理堆上未使用的数据以免耗尽空间，这些都是所有权解决的问题。一旦理解了所有权，您就不需要经常考虑堆栈和堆，但是知道所有权的主要目的是管理堆数据可以帮助解释为什么它会这样工作。
:::





### 栈Stack和堆Heap 保存数据

Stack 按值的接受顺序来存储，按相反的顺序将她们移除（后进先出 last in first out ）

添加数据家坳做压入栈，移除数据叫弹出栈

所有存储在 Stack 上的数据必须拥有已知的固定的大小，编译时大小未知或大小可能更改的数据必须存储在Heap上。

Heap 的组织性较差一些：

当您将数据放入堆上时，您会请求一定量的空间。

内存分配器在堆中找到一个足够大的空位，将其标记为正在使用，并返回一个指针，它是该位置的地址。这个过程称为在堆上分配，有时缩写为分配。

把值压到 Stack 上不叫分配，因为指针是已知固定大小的，可以报指针存放在Stack上，但是当您需要实际数据时，必须使用指针来定位。

把数据压到 Stack 上要比在 Heap 上分配更快，因为分配器永远不需要搜索存储新数据的位置；该位置始终位于Stack的顶部。

在Heap上分配空间要做更多的工作，操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配。

### 栈Stack和堆Heap 访问数据

访问 Heap 中的数据要比访问 Stack 中的数据慢，因为需要通过指针才能找到 Heap 中的数据

对于现代的处理器来说，由于缓存的远古，如果指令在内存中跳转的次数越少，那么速度越快。

如果数据存放的距离比较近，那么处理器的处理速度就会更快一些( Stack 上)

如果数据之间的距离比较远，那么处理速度就会慢一些( Heap 上)

Heap 上分配大量的空间也是需要时间的

### 函数调用

当代码调用函数时，值传入到函数（也包括指向 Heap的指针）。函数本地的变量被压到 Stack 上，当函数结束后哦，这些值会从 Stack 上弹出。

### 所有权存在的原因

所有权解决的问题

* 跟踪代码的哪些部分正在使用 heap 的哪些数据
* 最小化 heap 上的重复数据
* 清理 heap 上未使用的数据，以免耗尽空间

## 所有权规则

1. 每个值都有一个变量，这个变量是该值的所有者
2. 每个值同事只能有一个所有者
3. 当所有者超出作用域（scope）时，该值将被删除。


### 变量作用域

作用域 scope 就是程序中一个项目的有效范围


```rust
fn main() {
  // s; // s不可用
  let s = "hello"; // s可用
  // 可以对s 进行相关操作
}
// s // s不可用

```

